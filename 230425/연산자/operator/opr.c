
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

/*산술 연산자*/

//int main() {
//
//	int a = 39;
//	int b = 17;
//	int result;
//
//	result = a + b;
//	printf("a + b = %d 입니다. \n", result);
//
//	result = a - b;
//	printf("a - b = %d 입니다. \n", result);
//
//	result = a * b;
//	printf("a * b = %d 입니다. \n", result);
//
//	result = a / b;
//	printf("a / b = %d 입니다. \n", result);
//
//	result = a % b;
//	printf("a %% b = %d 입니다. \n", result);
//
//	return 0;
//}

/*대입 연산자*/

//int main() {
//
//	
//
//		int a = 34;
//
//		int c;
//
//		c = a;
//		printf("c = a 는 %d 입니다. \n", c);
//
//		c += a;
//		printf("c += a 는 %d 입니다. \n", c);
//
//		c -= a;
//		printf("c -= a 는 %d 입니다. \n", c);
//
//		c *= a;
//		printf("c *= a 는 %d 입니다. \n", c);
//
//		c /= a;
//		printf("c /= a 는 %d 입니다. \n", c);
//
//		c %= a;
//		printf("c %%= a 는 %d 입니다. \n", c);
//
//		a <<= 2;	// a = a<<2
//		printf("a <<= 2 는 %d 입니다. \n", a);
//
//		a >>= 2;	// a = a>>2
//		printf("a >>= 2 는 %d 입니다. \n", a);
//
//		return 0;
//	}


/*관계 연산자 ---> 결과는 0 또는 1이다. */
/*관계 연산자 주의할 점
  -  두 값이 같은지를 비교할 때는 == 를 사용
  -  10 < x < 20과 같이 수식을 사용해서는 안됨*/
//int main() {
//
//	int a = 0, b = 0;
//
//	printf("두 개의 정수 ? \n");
//	scanf("%d %d", &a, &b);
//
//	printf("%d > %d : %d\n", a, b, a > b);
//	printf("%d < %d : %d\n", a, b, a < b);
//	printf("%d >= %d : %d\n", a, b, a >= b);
//	printf("%d <= %d : %d\n", a, b, a <= b);
//	printf("%d == %d : %d\n", a, b, a == b);
//	printf("%d != %d : %d\n", a, b, a != b);
//
//	return 0;
//}

/*논리 연산자*/
//int main()
//{
//	int month;
//	printf("몇 월?\n");
//	scanf("%d", &month);
//	if (month >= 6 && month <= 8)
//
//	{
//		printf("성수기 요금 적용 \n");
//	}
//	if (month < 6 || month > 8)
//		printf("비수기 요금 적용\n");
//
//	//if(!(month >= 6 && month <= 8)) 위의 식과 같다.
//
//	return 0;
//
//}

/* &연산 */
//int main() {
//
//	int n1 = 15;			// 00000000 00000000 00000000 00001111
//	int n2 = 20;			// 00000000 00000000 00000000 00010100
//	int result = n1 & n2;	// 00000000 00000000 00000000 00000100
//
//	printf("n1 = %d \n", n1);
//	printf("n2 = %d \n", n2);
//	printf("result = %d \n", result);
//
//	return 0;
//}
//

/* | 연산 */
//int main() {
//
//	int n1 = 15;			// 00000000 00000000 00000000 00001111
//	int n2 = 20;			// 00000000 00000000 00000000 00010100
//	int result = n1 | n2;	// 00000000 00000000 00000000 00011111
//
//	printf("n1 = %d \n", n1);
//	printf("n2 = %d \n", n2);
//	printf("result = %d \n", result);
//
//	return 0;
//}
//

/* ^연산 */

//int main() {
//
//	int n1 = 15;			// 00000000 00000000 00000000 00001111
//	int n2 = 20;			// 00000000 00000000 00000000 00010100
//	int result = n1 ^ n2;	// 00000000 00000000 00000000 00011011
//
//	printf("n1 = %d \n", n1);
//	printf("n2 = %d \n", n2);
//	printf("result = %d \n", result);
//
//	return 0;
//}

/* ~연산 */

//int main() {
//
//	int n1 = -1;			// 11111111 11111111 11111111 11111111
//	int n2 = 0;				// 00000000 00000000 00000000 00010100
//
//	int result1 = ~n1;		// 00000000 00000000 00000000 00000000
//	int result2 = ~n2;		// 11111111 11111111 11111111 11111111
//
//	printf("n1 = %d \n", result1);
//	printf("n2 = %d \n", result2);
//
//	return 0;
//}

/* 쉬프트 연산 << */

//int main() {
//
//	int n = 1;				// 00000000 00000000 00000000 00000001
//
//	int r1 = n << 1;		// 00000000 00000000 00000000 00000010
//	int r2 = n << 2;		// 00000000 00000000 00000000 00000100
//	int r3 = n << 3;		// 00000000 00000000 00000000 00001000
//	int r4 = n << 4;		// 00000000 00000000 00000000 00010000
//
//	printf("결과1 = %d \n", r1);
//	printf("결과2 = %d \n", r2);
//	printf("결과3 = %d \n", r3);
//	printf("결과4 = %d \n", r4);
//
//	return 0;
//}

/* 쉬프트 연산 >> */
//int main() {
//
//	int n = 16;				// 00000000 00000000 00000000 00010000
//
//	int r1 = n >> 1;		// 00000000 00000000 00000000 00001000
//	int r2 = n >> 2;		// 00000000 00000000 00000000 00000100
//	int r3 = n >> 3;		// 00000000 00000000 00000000 00000010
//	int r4 = n >> 4;		// 00000000 00000000 00000000 00000001
//
//	printf("결과1 = %d \n", r1);
//	printf("결과2 = %d \n", r2);
//	printf("결과3 = %d \n", r3);
//	printf("결과4 = %d \n", r4);
//
//	return 0;
//}


/* 오버플로우(overFLOW) ==> 최대 범위를 넘어가는 경우 */

//int main() {
//
//	char a;
//
//	a = 127;
//	printf("%d \n", a);
//
//	a = 128;
//	printf("%d \n", a);
//
//	return 0;
//
//}




/* 언더플로우(overFLOW) ==> 최소값으로 넘어갈 때 */ 

//int main() {
//
//	char a;
//
//	a = -128;
//	printf("%d \n", a);
//
//	a = -129;
//	printf("%d \n", a);
//
//	return 0;
//
//}


/* 부호비트가 없을 때 언더플로우나 오버플로우가 생기는 경우*/
//int main() {
//
//	unsigned char a;
//
//	a = 255;
//	printf("%d \n", a);
//
//	a = 256;
//	printf("%d \n", a);
//
//	return 0;
//
//}

// 비트마스트
// 비트 논리연사에 이용 특정 비트값을 조작하기 위한 목적
// AND, OR 등의 연산자를 이용하여 비트를 조작
// 메모리를 적게 사용하기 위해
// 프로그램 더욱 빠르게 동작
// 소스코드가 직관적이다

/* 비트 마스크 & 연산 */
//int main() {
//
//	unsigned short data = 0x5678;	// 0101 0110 0111 1000
//
//	unsigned short msk1 = 0xf000;	// 1111 0000 0000 0000
//	unsigned short msk2 = 0x0f00;	// 0000 1111 0000 0000
//	unsigned short msk3 = 0x00f0;	// 0000 0000 1111 0000
//	unsigned short msk4 = 0x000f;	// 0000 0000 0000 1111
//
//	printf("결과 1 = %#.4x \n", data & msk1);
//	printf("결과 2 = %#.4x \n", data & msk2);
//	printf("결과 3 = %#.4x \n", data & msk3);
//	printf("결과 4 = %#.4x \n", data & msk4);
//
//	return 0;
//}

/* 비트 마스트 | 연산 */

//int main() {
//
//	unsigned short data = 0x0000;	// 0000 0000 0000 0000
//
//	unsigned short msk1 = 0xf000;	// 1111 0000 0000 0000
//	unsigned short msk2 = 0x0f00;	// 0000 1111 0000 0000
//	unsigned short msk3 = 0x00f0;	// 0000 0000 1111 0000
//	unsigned short msk4 = 0x000f;	// 0000 0000 0000 1111
//
//	printf("결과 1 = %#.4x \n", data | msk1);
//	printf("결과 2 = %#.4x \n", data | msk2);
//	printf("결과 3 = %#.4x \n", data | msk3);
//	printf("결과 4 = %#.4x \n", data | msk4);
//
//	return 0;
//}

// or연산도 동일하게 특정 부분만을 계산하여 식에 표시한다.
 // & 연산은 특정 비트를 0으로
 // | 연산은 특정 비트를 1로
 // ^ 연산은 특정 비트를 반전시킨다.



//원소추가(측정비트를 1로 변환)
// 0b00001 <<3 ----> 0b01000 왼쪽으로 3번 옮김
// a |=(1<<k)  ---> 1을 K 번째로 옮김
// 0b10101 < 3번째 값을 추가  ----> 0b11101
// 0b00001 <<3 
// -------
// 0b11101

// 원소 삭제(특정비트를 0으로)
// a &= ~(1<<k) ==> 1을 k번째 왼쪽으로 옮김
// 0b11101 0b00001 ==> 0b01001 ==> 0b10111
// 0b010111
//---------
// 0b10101

// 조회
// if(a & (1<<k)) 명령문;


// 토글
// a ^=(1<<k)
//

/* 형변환 연산자 */

//int main() {
//
//	int a, b, c;
//	double average;
//
//	printf("정수 3개를 입력하시오 :");
//	scanf("%d %d %d", &a, &b, &c);
//
//	average = (double)(a + b + c) / 3;
//	printf("평균 : %f \n", average);
//
//	return 0;
//
//}
